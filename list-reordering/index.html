<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <title>Drag to reorder - Fuse Examples</title>
    <link rel="stylesheet" href="https://fuse-open.github.io/examples/bootstrap.css">
    <link rel="stylesheet" href="https://fuse-open.github.io/examples/prism.css">
    <link rel="stylesheet" href="https://fuse-open.github.io/examples/site.css">
  </head>

  <body>

    <nav class="navbar navbar-dark bg-dark flex-md-nowrap">
      <a class="navbar-brand" href="https://fuse-open.github.io/examples/">Fuse: Examples</a>
    </nav>

    <div class="container-fluid main-content-wrapper">
      <div class="row">
        <div class="col-md-2 d-none d-md-block bg-light sidebar">
          <div class="sidebar-sticky">
            <p class="example-back-link">
&lt; <a href="../index.html">Go back</a>
</p>
<p class="example-download-link">
<a href="../bundles/list-reordering.zip" class="btn btn-primary btn-block">Download example</a>
</p>
<h6>Tags</h6>
<p class="example-tags">
<a href="../tag_customcontrol.html">Custom control</a>, <a href="../tag_javascript.html">JavaScript</a>, <a href="../tag_reusablecomponents.html">Reusable components</a>, <a href="../tag_animation.html">Animation</a>
</p>
<h6>UX Concepts</h6>
<ul class="nav flex-column concepts-nav">
<li class="nav-item"><a href="https://fuse-open.github.io/docs/fuse/controls/scrollview.html" class="nav-link">ScrollView</a></li>
<li class="nav-item"><a href="https://fuse-open.github.io/docs/fuse/controls/stackpanel.html" class="nav-link">StackPanel</a></li>
<li class="nav-item"><a href="https://fuse-open.github.io/docs/fuse/triggers/whiletrue.html" class="nav-link">WhileTrue</a></li>
<li class="nav-item"><a href="https://fuse-open.github.io/docs/fuse/animations/change_1.html" class="nav-link">Change</a></li>
<li class="nav-item"><a href="https://fuse-open.github.io/docs/fuse/gestures/released.html" class="nav-link">Released</a></li>
<li class="nav-item"><a href="https://fuse-open.github.io/docs/fuse/triggers/actions/callback.html" class="nav-link">Callback</a></li>
<li class="nav-item"><a href="https://fuse-open.github.io/docs/fuse/controls/dockpanel.html" class="nav-link">DockPanel</a></li>
<li class="nav-item"><a href="https://fuse-open.github.io/docs/fuse/gestures/pressed.html" class="nav-link">Pressed</a></li>
<li class="nav-item"><a href="https://fuse-open.github.io/docs/fuse/reactive/each.html" class="nav-link">Each</a></li>
<li class="nav-item"><a href="https://fuse-open.github.io/docs/fuse/triggers/layoutanimation.html" class="nav-link">LayoutAnimation</a></li>
<li class="nav-item"><a href="https://fuse-open.github.io/docs/fuse/animations/move.html" class="nav-link">Move</a></li>
<li class="nav-item"><a href="https://fuse-open.github.io/docs/fuse/gestures/whilehovering.html" class="nav-link">WhileHovering</a></li>
</ul>

<h6>JS Concepts</h6>
<ul class="nav flex-column concepts-nav">
<li class="nav-item"><a href="https://fuse-open.github.io/docs/fusejs/observable.html" class="nav-link">Observable</a></li>
<li class="nav-item"><a href="https://fuse-open.github.io/docs/fusejs/observable-api.html#replaceall-array" class="nav-link">Observable.replaceAll</a></li>
<li class="nav-item"><a href="https://fuse-open.github.io/docs/fuse/reactive/databinding.html" class="nav-link">data-binding</a></li>
</ul>


          </div>
        </div>
        <div role="main" class="col-md-9 ml-sm-auto col-lg-10 px-4 main-content">
          <h1>Drag to reorder</h1>

          <div class="example-content-preview example-content-preview-slot-3">
<video autoplay="true" loop="true"><source src="media/preview.mp4" type="video/mp4"></video>
</div>
<div class="example-content-body">
<p>In this example we show how to create a drag-to-reorder behaviour on a list of items. This was made possible by the introduction of <code>IdentityKey</code> property on <code>Each</code> tag, which takes care of figuring out which items are where after a list has been modified.</p>
<h3>Making a component</h3
<p>Since we want to have code that we can reuse in multiple places, we build a custom <code>ux:Class</code> component for our <code>SortableList</code> element. We will need to change the order of items that we pass in through <code>ux:Property</code>, so that list has to be an Observable. The type of the property needs to be <code>object</code>. Since we are going to make changes to the list inside of our custom component, we need to make a component-local viewmodel (in-line JavaScript in our component) that will hold the business logic and access the list of items.</p>
<pre><code>&lt;Panel ux:Class=&quot;SortableList&quot;&gt;
    &lt;object ux:Property=&quot;Items&quot; /&gt;
    &lt;string ux:Property=&quot;Label&quot; /&gt;

    &lt;JavaScript&gt;
    var items = this.Items.inner();
    module.exports = {
        items: items
    };
    &lt;/JavaScript&gt;
</code></pre>
<p>Am important detail to keep in mind when <a href="https://fuse-open.github.io/docs/ux-markup/properties#passing-observables-through-properties">passing Observables through properties</a> is that the property itself is a <a href="https://fuse-open.github.io/docs/fusejs/observable-api#state-observables-and-derived-observables">derived Observable</a>, so we need to use <code>.inner()</code> to get access to the Observable list.</p>
<p>The visual part of our component is relatively simple: it's a <code>StackPanel</code> that stacks the label and list of items. What's interesting is the <code>Each</code> tag with <code>IdentityKey=&quot;id&quot;</code> property set. When the items in the data-bound list change, <code>Each</code> will check the property <code>id</code> on every item in the list and figure out which items are the same.</p>
<pre><code>&lt;StackPanel ItemSpacing=&quot;8&quot;&gt;
    &lt;Text Value=&quot;{ReadProperty Label}&quot; TextColor=&quot;#777&quot; FontSize=&quot;18&quot; Font=&quot;Bold&quot; Margin=&quot;8,0&quot; Alignment=&quot;CenterLeft&quot; /&gt;
    &lt;StackPanel ItemSpacing=&quot;1&quot;&gt;
        &lt;Each Items=&quot;{items}&quot; IdentityKey=&quot;id&quot;&gt;
            &lt;Item /&gt;
        &lt;/Each&gt;
    &lt;/StackPanel&gt;
&lt;/StackPanel&gt;
</code></pre>
<p>Each item in the list is represented by another <code>ux:Class</code>. It shows the title of the item and includes a handle that we will drag the items by.</p>
<pre><code>&lt;DockPanel ux:Class=&quot;Item&quot; Height=&quot;56&quot;&gt;
    &lt;Text Value=&quot;{title}&quot; Alignment=&quot;CenterLeft&quot; TextColor=&quot;#444&quot; Margin=&quot;8,0&quot; /&gt;
    &lt;Panel Width=&quot;56&quot; Dock=&quot;Right&quot; HitTestMode=&quot;LocalBounds&quot;&gt;
        &lt;StackPanel Width=&quot;16&quot; ItemSpacing=&quot;2&quot; Alignment=&quot;Center&quot;&gt;
            &lt;Each Count=&quot;4&quot;&gt;
                &lt;Rectangle Height=&quot;2&quot; Color=&quot;#bbb&quot; CornerRadius=&quot;1&quot; /&gt;
            &lt;/Each&gt;
        &lt;/StackPanel&gt;
    &lt;/Panel&gt;
    &lt;Rectangle ux:Name=&quot;underlay&quot; Color=&quot;#fff&quot; Opacity=&quot;1&quot; CornerRadius=&quot;2&quot; Layer=&quot;Background&quot; /&gt;
&lt;/DockPanel&gt;
</code></pre>
<p>Our <code>MainView.ux</code> will hold 3 instances of the <code>SortableList</code> component, and we will put them inside of a <code>ScrollView</code> so that we can scroll to see items that are beyond the screen. This raises a challenge when we need to reorder the list, because tapping and then dragging the items will simply make the <code>ScrollView</code> scroll.</p>
<p>To solve this challenge, we need to pass in the parent <code>ScrollView</code> via <code>ux:Dependency</code> and disable <code>UserScroll</code> on it while we're reordering items.</p>
<pre><code>&lt;ScrollView ux:Dependency=&quot;parentScrollView&quot; /&gt;
...
&lt;WhileTrue Value=&quot;{reordering}&quot;&gt;
    &lt;Change parentScrollView.UserScroll=&quot;false&quot; /&gt;
&lt;/WhileTrue&gt;
</code></pre>
<p>We will set the variable <code>{reordering}</code> to <code>true</code> when any one of the drag handles are <code>Pressed</code> and set it back to <code>false</code> when the list item is <code>Released</code>.</p>
<pre><code>&lt;Pressed&gt;
    &lt;Callback Handler=&quot;{select}&quot; /&gt;
&lt;/Pressed&gt;
...
&lt;Released&gt;
    &lt;Callback Handler=&quot;{deselect}&quot; /&gt;
&lt;/Released&gt;
</code></pre>
<p>Thanks to the <code>IdentityKey</code> on <code>Each</code>, an item in a list now gets its <code>LayoutAnimation</code> triggered when it changes its position in that list. We take advantage of that, and specify how that animation should look. In our example, an item can only be moved by one index at a time, so it makes sense to have a really simple and quick animation.</p>
<pre><code>&lt;LayoutAnimation&gt;
    &lt;Move RelativeTo=&quot;PositionChange&quot; Vector=&quot;1&quot; Duration=&quot;0.16&quot; /&gt;
&lt;/LayoutAnimation&gt;
</code></pre>
<p>To change the order of items within our list, we use a <code>WhileHovering</code> trigger. It works like this: while we have an item <code>Pressed</code> and we're moving the pointer (finger) over another list item, the <code>{hover}</code> callback fires. In there, we will remove the item we originally <code>Pressed</code> from the list and insert it at the new index.</p>
<pre><code>&lt;WhileHovering&gt;
    &lt;Callback Handler=&quot;{hover}&quot; /&gt;
&lt;/WhileHovering&gt;
</code></pre>
<p>This is how the UX code for our <code>Item</code> component looks like when we put all the bits together:</p>
<pre><code>&lt;DockPanel ux:Class=&quot;Item&quot; Height=&quot;56&quot;&gt;
    &lt;Text Value=&quot;{title}&quot; Alignment=&quot;CenterLeft&quot; TextColor=&quot;#444&quot; Margin=&quot;8,0&quot; /&gt;
    &lt;Panel Width=&quot;56&quot; Dock=&quot;Right&quot; HitTestMode=&quot;LocalBounds&quot;&gt;
        &lt;Pressed&gt;
            &lt;Callback Handler=&quot;{select}&quot; /&gt;
        &lt;/Pressed&gt;
        &lt;StackPanel Width=&quot;16&quot; ItemSpacing=&quot;2&quot; Alignment=&quot;Center&quot;&gt;
            &lt;Each Count=&quot;4&quot;&gt;
                &lt;Rectangle Height=&quot;2&quot; Color=&quot;#bbb&quot; CornerRadius=&quot;1&quot; /&gt;
            &lt;/Each&gt;
        &lt;/StackPanel&gt;
    &lt;/Panel&gt;
    &lt;LayoutAnimation&gt;
        &lt;Move RelativeTo=&quot;PositionChange&quot; Vector=&quot;1&quot; Duration=&quot;0.16&quot; /&gt;
    &lt;/LayoutAnimation&gt;
    &lt;WhileHovering&gt;
        &lt;Callback Handler=&quot;{hover}&quot; /&gt;
    &lt;/WhileHovering&gt;
    &lt;WhileTrue Value=&quot;{selected}&quot;&gt;
        &lt;Change underlay.Opacity=&quot;0.6&quot; Duration=&quot;0.24&quot; /&gt;
    &lt;/WhileTrue&gt;
    &lt;Rectangle ux:Name=&quot;underlay&quot; Color=&quot;#fff&quot; Opacity=&quot;1&quot; CornerRadius=&quot;2&quot; Layer=&quot;Background&quot; /&gt;
&lt;/DockPanel&gt;
</code></pre>
<p>Now we need to implement the business logic in JavaScript so that our callbacks actually do something. As described before, the list reordering logic resides in the <code>hover()</code> function, while the <code>select()</code> and <code>deselect()</code> functions toggle the <code>reordering</code> state and make sure the right data is in place when necessary.</p>
<pre><code>&lt;JavaScript&gt;
var Observable = require(&quot;FuseJS/Observable&quot;);
var items = this.Items.inner();

var selected = null;
var reordering = Observable(false);

function select(args) {
    if (selected === null) {
        selected = args.data.id;
        items.forEach(function(x) {
            if (x.id === selected) {
                x.selected.value = true;
            }
        });
    }
    reordering.value = true;
}

function deselect() {
    selected = null;
    items.forEach(function(x) {
        x.selected.value = false;
    });
    reordering.value = false;
}

function hover(args) {
    if (reordering.value === true &amp;&amp; selected !== null) {
        var from;
        var to;
        items.forEach(function(item, index) {
            if (item.id === selected) {
                from = index;
            }
            if (item.id === args.data.id) {
                to = index;
            }
        });
        if (to !== from &amp;&amp; to !== undefined) {
            var tmp = items.toArray();
            var elem = tmp[from];
            tmp.splice(from, 1);
            tmp.splice(to, 0, elem);
            items.replaceAll(tmp);
        }
    }
}

module.exports = {
    items: items,
    reordering: reordering,
    select: select,
    deselect: deselect,
    hover: hover
};
&lt;/JavaScript&gt;
</code></pre>
<h3>Using the component</h3
<p>With the <code>SortableList</code> component done, it's time we use it in our <code>MainView.ux</code>!</p>
<p>We start by creating 3 Observable lists of items in JavaScript:</p>
<pre><code>&lt;JavaScript&gt;
var Observable = require(&quot;FuseJS/Observable&quot;);

function Item(id, title) {
    this.id = id;
    this.title = title;
    this.selected = Observable(false);
}

var morning = Observable(
    new Item(1, &quot;Brush your teeth&quot;),
    new Item(2, &quot;Take out the trash&quot;),
    new Item(3, &quot;Take the stairs&quot;)
);
var day = Observable(
    new Item(1, &quot;Buy milk&quot;),
    new Item(2, &quot;Make an app&quot;),
    new Item(3, &quot;Learn something new&quot;)
);
var evening = Observable(
    new Item(1, &quot;Dinner with mom&quot;),
    new Item(2, &quot;Play chess with a friend&quot;),
    new Item(3, &quot;Watch TV&quot;)
);

module.exports = {
    morning: morning,
    day: day,
    evening: evening
};
&lt;/JavaScript&gt;
</code></pre>
<p>Next, we add our <code>ScrollView</code> and assign it a <code>ux:Name</code>. Inside there, we stack 3 instances of our <code>SortableList</code> component, pass the <code>ux:Dependency</code> for <code>ScrollView</code> and data-bind the respective lists of items.</p>
<pre><code>&lt;ScrollView ux:Name=&quot;parentScrollView&quot;&gt;
    &lt;StackPanel Margin=&quot;8,16&quot; ItemSpacing=&quot;24&quot;&gt;
        &lt;SortableList Items=&quot;{morning}&quot; parentScrollView=&quot;parentScrollView&quot; Label=&quot;Morning&quot; /&gt;
        &lt;SortableList Items=&quot;{day}&quot; parentScrollView=&quot;parentScrollView&quot; Label=&quot;Day&quot; /&gt;
        &lt;SortableList Items=&quot;{evening}&quot; parentScrollView=&quot;parentScrollView&quot; Label=&quot;Evening&quot; /&gt;
    &lt;/StackPanel&gt;
&lt;/ScrollView&gt;
</code></pre>
<p>And now we can reorder lists by dragging items! Go ahead, download the example and make your own drag-to-reorder components!</p>

</div>

        </div>
      </div>
    </div>

    <script type="text/javascript" src="https://fuse-open.github.io/examples/jquery.js"></script>
    <script type="text/javascript" src="https://fuse-open.github.io/examples/popper.js"></script>
    <script type="text/javascript" src="https://fuse-open.github.io/examples/bootstrap.js"></script>
    <script type="text/javascript" src="https://fuse-open.github.io/examples/prism.js"></script>
    <script type="text/javascript" src="https://fuse-open.github.io/examples/site.js"></script>
  </body>
</html>
